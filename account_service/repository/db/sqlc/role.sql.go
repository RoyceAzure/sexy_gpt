// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: role.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRole = `-- name: CreateRole :one
INSERT INTO "role"(
    role_name,
    cr_user
) VALUES(
    $1,$2
) RETURNING role_id, role_name, is_enable, cr_date, up_date, cr_user, up_user
`

type CreateRoleParams struct {
	RoleName string `json:"role_name"`
	CrUser   string `json:"cr_user"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, createRole, arg.RoleName, arg.CrUser)
	var i Role
	err := row.Scan(
		&i.RoleID,
		&i.RoleName,
		&i.IsEnable,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}

const getRole = `-- name: GetRole :one
SELECT role_id, role_name, is_enable, cr_date, up_date, cr_user, up_user FROM "role"
WHERE role_id = $1 LIMIT 1
`

func (q *Queries) GetRole(ctx context.Context, roleID pgtype.UUID) (Role, error) {
	row := q.db.QueryRow(ctx, getRole, roleID)
	var i Role
	err := row.Scan(
		&i.RoleID,
		&i.RoleName,
		&i.IsEnable,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}

const getRoleByRoleName = `-- name: GetRoleByRoleName :one
SELECT role_id, role_name, is_enable, cr_date, up_date, cr_user, up_user FROM "role"
WHERE role_name = $1 LIMIT 1
`

func (q *Queries) GetRoleByRoleName(ctx context.Context, roleName string) (Role, error) {
	row := q.db.QueryRow(ctx, getRoleByRoleName, roleName)
	var i Role
	err := row.Scan(
		&i.RoleID,
		&i.RoleName,
		&i.IsEnable,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}

const getRoles = `-- name: GetRoles :many
SELECT role_id, role_name, is_enable, cr_date, up_date, cr_user, up_user FROM "role"
ORDER BY role_id
LIMIT $1
OFFSET $2
`

type GetRolesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetRoles(ctx context.Context, arg GetRolesParams) ([]Role, error) {
	rows, err := q.db.Query(ctx, getRoles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.RoleID,
			&i.RoleName,
			&i.IsEnable,
			&i.CrDate,
			&i.UpDate,
			&i.CrUser,
			&i.UpUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRole = `-- name: UpdateRole :one
UPDATE "role"
SET 
    role_name = COALESCE($1,role_name),
    is_enable = COALESCE($2,is_enable),
    up_date = COALESCE($3,up_date),
    up_user = COALESCE($4,up_user)
WHERE role_id = $5
RETURNING role_id, role_name, is_enable, cr_date, up_date, cr_user, up_user
`

type UpdateRoleParams struct {
	RoleName pgtype.Text        `json:"role_name"`
	IsEnable pgtype.Bool        `json:"is_enable"`
	UpDate   pgtype.Timestamptz `json:"up_date"`
	UpUser   pgtype.Text        `json:"up_user"`
	RoleID   pgtype.UUID        `json:"role_id"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, updateRole,
		arg.RoleName,
		arg.IsEnable,
		arg.UpDate,
		arg.UpUser,
		arg.RoleID,
	)
	var i Role
	err := row.Scan(
		&i.RoleID,
		&i.RoleName,
		&i.IsEnable,
		&i.CrDate,
		&i.UpDate,
		&i.CrUser,
		&i.UpUser,
	)
	return i, err
}
